<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Global Heartbeat AI – Planetarny puls ludzkości (DEMO)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Global Heartbeat AI – demo globusa 3D z kolorowymi klastrami zdarzeń, filtrowaniem ryzyka oraz opisem regionu i scenariusza."
  />
  <style>
    :root {
      --bg-main: #050713;
      --bg-panel: rgba(7, 10, 28, 0.96);
      --border-soft: rgba(142, 162, 255, 0.35);
      --accent: #b3c7ff;
      --accent-strong: #ff8ddc;
      --accent-warm: #ffc857;
      --text-main: #f5f7ff;
      --text-soft: #aeb3d9;
      --radius-xl: 18px;
      --shadow-soft: 0 18px 40px rgba(0, 0, 0, 0.55);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at 10% 0, #262f72 0, transparent 45%),
        radial-gradient(circle at 80% 120%, #3d1649 0, transparent 55%),
        var(--bg-main);
      color: var(--text-main);
      overflow: hidden;
    }

    body {
      display: grid;
      grid-template-columns: minmax(0, 1.5fr) minmax(380px, 0.9fr);
      grid-template-rows: 100vh;
    }

    #globe-shell {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }

    #globe-container {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: var(--radius-xl);
      overflow: hidden;
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: radial-gradient(circle at top, #111741, #050713 65%);
    }

    #tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(5, 7, 24, 0.97);
      border-radius: 10px;
      padding: 8px 10px;
      border: 1px solid rgba(163, 190, 255, 0.8);
      font-size: 11px;
      color: var(--text-main);
      white-space: nowrap;
      transform: translate(10px, 10px);
      opacity: 0;
      transition: opacity 0.1s ease-out;
      z-index: 10;
      max-width: 280px;
    }

    /* Prawy panel */
    #side-panel {
      height: 100vh;
      padding: 18px 18px 18px 0;
      display: flex;
      flex-direction: column;
    }

    .panel-card {
      background: var(--bg-panel);
      border-radius: var(--radius-xl);
      border: 1px solid var(--border-soft);
      box-shadow: var(--shadow-soft);
      padding: 14px 16px;
      margin-bottom: 12px;
    }

    #header-card {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .brand-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--accent);
      opacity: 0.9;
    }

    .brand-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: radial-gradient(circle, var(--accent-strong), transparent 70%);
      box-shadow: 0 0 10px var(--accent-strong);
    }

    h1 {
      font-size: 20px;
      margin: 0;
      letter-spacing: 0.02em;
    }

    .subtitle {
      font-size: 12px;
      color: var(--text-soft);
      margin: 0;
    }

    .tag-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }

    .tag {
      font-size: 10px;
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid rgba(180, 195, 255, 0.7);
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    #controls-card { font-size: 11px; }

    #controls-card h2,
    #metrics-card h2,
    #about-card h2 {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--accent);
      margin: 0 0 6px;
    }

    #controls-card label {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
      cursor: pointer;
    }

    #controls-card input[type="checkbox"] {
      accent-color: var(--accent-strong);
    }

    #risk-value {
      font-variant-numeric: tabular-nums;
      color: var(--accent-warm);
      font-weight: 600;
    }

    #risk-slider { width: 100%; }

    .controls-row {
      margin-top: 8px;
      padding-top: 6px;
      border-top: 1px dashed rgba(120, 130, 190, 0.6);
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
      font-size: 10px;
      color: var(--text-soft);
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 6px;
      border-radius: 999px;
      background: rgba(10, 14, 40, 0.9);
      border: 1px solid rgba(150, 170, 255, 0.5);
    }

    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
    }

    .legend-normal { background:#00ffd5; }
    .legend-heat { background:#ff5500; }
    .legend-flood { background:#008cff; }
    .legend-conflict { background:#ff008a; }
    .legend-infra { background:#ffd400; }

    /* Metrics */
    #metrics-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }

    .metric-tile {
      background: radial-gradient(circle at top, rgba(60, 70, 140, 0.9), rgba(7, 10, 28, 0.95));
      border-radius: 12px;
      padding: 6px 7px;
      border: 1px solid rgba(147, 164, 255, 0.8);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.7);
    }

    .metric-label {
      font-size: 10px;
      color: var(--text-soft);
      margin-bottom: 2px;
    }

    .metric-value {
      font-size: 13px;
      font-variant-numeric: tabular-nums;
    }

    .metric-unit {
      font-size: 10px;
      color: var(--text-soft);
      margin-left: 2px;
    }

    .metric-pill {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      margin-top: 3px;
      display: inline-block;
      color: var(--accent);
    }

    #m-events {
      font-variant-numeric: tabular-nums;
      color: var(--accent);
    }

    /* About / sections */
    #about-card {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    #about-scroll {
      overflow-y: auto;
      padding-right: 4px;
      max-height: 100%;
    }

    .about-block { margin-bottom: 10px; }

    .about-block h3 {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      margin: 0 0 4px;
      color: var(--accent);
    }

    .about-block p {
      font-size: 11px;
      color: var(--text-soft);
      margin: 0;
      line-height: 1.4;
    }

    .about-list {
      margin: 4px 0 0;
      padding-left: 14px;
      font-size: 11px;
      color: var(--text-soft);
    }

    .about-list li { margin-bottom: 3px; }

    code {
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10px;
      background: rgba(10, 12, 32, 0.9);
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid rgba(110, 130, 210, 0.5);
    }

    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    @media (max-width: 900px) {
      body {
        grid-template-columns: 1fr;
        grid-template-rows: 55vh 45vh;
      }
      #side-panel { padding: 0 12px 12px 12px; }
      #globe-shell { padding: 10px; }
      #globe-container { border-radius: 14px; }
    }
  </style>
</head>
<body>
  <!-- LEWA: GLOBUS 3D -->
  <div id="globe-shell">
    <div id="globe-container">
      <div id="tooltip"></div>
    </div>
  </div>

  <!-- PRAWA: PANEL -->
  <aside id="side-panel">
    <section id="header-card" class="panel-card">
      <div class="brand-label">
        <span class="brand-dot"></span>
        GLOBAL HEARTBEAT AI – DEMO
      </div>
      <h1>Planetarny puls ludzkości</h1>
      <p class="subtitle">
        Kolorowe klastry zdarzeń na globusie 3D. Każdy punkt ma przypisany region i scenariusz AI (demo).
      </p>
      <div class="tag-row">
        <span class="tag">DEMO</span>
        <span class="tag">3D Globe</span>
        <span class="tag">AI Events</span>
      </div>
    </section>

    <section id="controls-card" class="panel-card">
      <h2>Filtry zdarzeń / ryzyka</h2>
      <div>
        <label><input type="checkbox" data-event="normal" checked /> normal (turkus)</label>
        <label><input type="checkbox" data-event="heatwave_risk" checked /> heatwave_risk (pomarańczowy)</label>
        <label><input type="checkbox" data-event="flood_risk" checked /> flood_risk (niebieski)</label>
        <label><input type="checkbox" data-event="conflict_risk" checked /> conflict_risk (róż/fuksja)</label>
        <label><input type="checkbox" data-event="infrastructure_stress" checked /> infrastructure_stress (żółty)</label>
      </div>

      <div class="legend">
        <div class="legend-item"><span class="legend-dot legend-normal"></span>normal</div>
        <div class="legend-item"><span class="legend-dot legend-heat"></span>heatwave</div>
        <div class="legend-item"><span class="legend-dot legend-flood"></span>flood</div>
        <div class="legend-item"><span class="legend-dot legend-conflict"></span>conflict</div>
        <div class="legend-item"><span class="legend-dot legend-infra"></span>infra</div>
      </div>

      <div class="controls-row">
        Min. risk_index:
        <span id="risk-value">0.00</span><br />
        <input id="risk-slider" type="range" min="0" max="100" value="0" />
        <p style="margin:4px 0 0; color:var(--text-soft); font-size:10px;">
          Przesuń w prawo, aby zostawić tylko najmocniejsze punkty (największe i najbardziej „nerwowe”).
        </p>
      </div>

      <div class="controls-row" style="display:flex;justify-content:space-between;align-items:center;">
        <span style="font-size:10px;color:var(--text-soft);">
          Źródło danych:
          <span id="data-mode-label" style="color:var(--accent-warm); font-weight:600;">DEMO / offline</span>
        </span>
        <span style="font-size:10px;color:var(--text-soft);" id="snapshot-time"></span>
      </div>
    </section>

    <section id="metrics-card" class="panel-card">
      <h2>Szybkie metryki snapshotu</h2>
      <div id="metrics-grid">
        <div class="metric-tile">
          <div class="metric-label">Średni HR</div>
          <div class="metric-value"><span id="m-avg-hr">–</span><span class="metric-unit">bpm</span></div>
          <div class="metric-pill">dzień+noc</div>
        </div>
        <div class="metric-tile">
          <div class="metric-label">Średni HRV</div>
          <div class="metric-value"><span id="m-avg-hrv">–</span><span class="metric-unit">unit</span></div>
          <div class="metric-pill">zmienność</div>
        </div>
        <div class="metric-tile">
          <div class="metric-label">Widoczne punkty</div>
          <div class="metric-value"><span id="m-count">–</span></div>
          <div class="metric-pill">po filtrach</div>
        </div>
      </div>
      <div style="margin-top:6px;font-size:10px;color:var(--text-soft);">
        Aktywne zdarzenia: <span id="m-events">–</span>
      </div>
    </section>

    <section id="about-card" class="panel-card">
      <h2>O projekcie / układ klastrów</h2>
      <div id="about-scroll">
        <div class="about-block">
          <h3>Cel tej wersji DEMO</h3>
          <p>
            Ta wersja pokazuje, jak mógłby wyglądać panel „oglądający” planetarny puls ludzkości:
            każdy punkt ma przypisaną <b>lokalizację (region/kraj)</b> oraz <b>opis scenariusza</b>, który tłumaczy,
            dlaczego AI (w trybie demonstracyjnym) oznaczyła go jako dany typ ryzyka.
          </p>
        </div>

        <div class="about-block">
          <h3>Przykładowe scenariusze (demo)</h3>
          <ul class="about-list">
            <li><b>heatwave_risk</b> – wysoka temperatura, podniesiony HR, obniżone HRV, długotrwały upał,</li>
            <li><b>flood_risk</b> – pas równikowy, zwiększona wilgotność i intensywne opady,</li>
            <li><b>conflict_risk</b> – regiony o podwyższonym napięciu geopolitycznym, wyższe HR i obciążenie stresem,</li>
            <li><b>infrastructure_stress</b> – gęsto zaludnione megamiasta, wysoka aktywność i przeciążenie sieci,</li>
            <li><b>normal</b> – tło populacyjne, zwykła dobowa fizjologia.</li>
          </ul>
          <p style="margin-top:4px;">
            Wszystkie przykłady są syntetyczne, ale struktura danych odpowiada temu, co można byłoby podłączyć
            do realnych strumieni HR/HRV i danych środowiskowych.
          </p>
        </div>
      </div>
    </section>
  </aside>

  <!-- SCRIPT: moduł z importem THREE -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";

    (function() {
      const container = document.getElementById("globe-container");
      const tooltip = document.getElementById("tooltip");
      const riskSlider = document.getElementById("risk-slider");
      const riskValueLabel = document.getElementById("risk-value");
      const dataModeLabel = document.getElementById("data-mode-label");
      const snapshotTimeLabel = document.getElementById("snapshot-time");
      const checkboxes = Array.from(
        document.querySelectorAll('#controls-card input[type="checkbox"]')
      );

      const mAvgHR = document.getElementById("m-avg-hr");
      const mAvgHRV = document.getElementById("m-avg-hrv");
      const mCount = document.getElementById("m-count");
      const mEvents = document.getElementById("m-events");

      let scene, camera, renderer;
      let globeMesh, wireMesh, atmosphereMesh;
      let pointsGroup;
      let raycaster, mouse;
      let isDragging = false;
      let prevMouse = { x: 0, y: 0 };
      let targetRot = { x: 0, y: 0 };
      let currentRot = { x: 0, y: 0 };
      let globeData = [];

      const radius = 1.2;

      // MOCNE kolory – ekstremalnie kontrastowe
      const colorMap = {
        normal: new THREE.Color(0x00ffd5),            // turkus
        heatwave_risk: new THREE.Color(0xff5500),     // pomarańcz
        flood_risk: new THREE.Color(0x008cff),        // niebieski
        conflict_risk: new THREE.Color(0xff008a),     // róż/fuksja
        infrastructure_stress: new THREE.Color(0xffd400), // żółty
      };

      function initScene() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050713);

        const width = container.clientWidth || window.innerWidth;
        const height = container.clientHeight || window.innerHeight;

        camera = new THREE.PerspectiveCamera(52, width / height, 0.1, 100);
        camera.position.set(0, 0, 4.2);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(3, 2, 3);
        scene.add(dirLight);

        const globeGeo = new THREE.SphereGeometry(radius, 64, 64);
        const globeMat = new THREE.MeshPhongMaterial({
          color: 0x24348f,
          emissive: 0x050713,
          shininess: 40,
          transparent: true,
          opacity: 0.96,
        });
        globeMesh = new THREE.Mesh(globeGeo, globeMat);
        scene.add(globeMesh);

        const wireGeo = new THREE.SphereGeometry(radius * 1.003, 32, 32);
        const wireMat = new THREE.MeshBasicMaterial({
          color: 0x5c6ff0,
          wireframe: true,
          transparent: true,
          opacity: 0.36,
        });
        wireMesh = new THREE.Mesh(wireGeo, wireMat);
        scene.add(wireMesh);

        const atmoGeo = new THREE.SphereGeometry(radius * 1.06, 40, 40);
        const atmoMat = new THREE.MeshBasicMaterial({
          color: 0x86c7ff,
          transparent: true,
          opacity: 0.22,
        });
        atmosphereMesh = new THREE.Mesh(atmoGeo, atmoMat);
        scene.add(atmosphereMesh);

        const starsGeometry = new THREE.BufferGeometry();
        const starCount = 900;
        const positions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
          const r = 9 + Math.random() * 8;
          const theta = Math.random() * 2 * Math.PI;
          const phi = Math.acos(2 * Math.random() - 1);
          positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
          positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
          positions[i * 3 + 2] = r * Math.cos(phi);
        }
        starsGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        const starsMaterial = new THREE.PointsMaterial({
          size: 0.04,
          color: 0xaec4ff,
          transparent: true,
          opacity: 0.45,
        });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        pointsGroup = new THREE.Group();
        scene.add(pointsGroup);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        window.addEventListener("resize", onResize);
        container.addEventListener("mousemove", onMouseMove);
        container.addEventListener("mouseleave", () => (tooltip.style.opacity = 0));
        container.addEventListener("mousedown", onMouseDown);
        container.addEventListener("mouseup", onMouseUp);
        container.addEventListener("mouseout", onMouseUp);

        animate();
      }

      function onResize() {
        const width = container.clientWidth || window.innerWidth;
        const height = container.clientHeight || window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }

      function latLonToVector3(lat, lon, r = radius) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);
        const x = -r * Math.sin(phi) * Math.cos(theta);
        const z = r * Math.sin(phi) * Math.sin(theta);
        const y = r * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
      }

      function clearPoints() {
        while (pointsGroup.children.length > 0) {
          const child = pointsGroup.children.pop();
          child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) child.material.forEach((m) => m.dispose());
            else child.material.dispose();
          }
        }
      }

      function buildPoints() {
        clearPoints();
        if (!globeData || globeData.length === 0) {
          updateMetrics([]);
          return;
        }

        const minRisk = parseFloat(riskSlider.value) / 100.0;
        const enabledEvents = new Set(
          checkboxes.filter((cb) => cb.checked).map((cb) => cb.dataset.event)
        );

        const visible = [];

        globeData.forEach((p) => {
          if (!enabledEvents.has(p.event_type)) return;
          if (p.risk_index < minRisk) return;

          visible.push(p);

          const pos = latLonToVector3(p.lat, p.lon);
          const baseSize = 0.02 + 0.05 * p.risk_index;

          const geom = new THREE.SphereGeometry(baseSize, 18, 18);
          const baseColor = colorMap[p.event_type] || colorMap.normal;

          const mat = new THREE.MeshBasicMaterial({
            color: baseColor,
          });

          const mesh = new THREE.Mesh(geom, mat);
          mesh.position.copy(pos);
          mesh.userData = {
            ...p,
            baseSize: baseSize,
          };
          pointsGroup.add(mesh);
        });

        updateMetrics(visible);
      }

      function updateTooltip(event) {
        const rect = container.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        mouse.x = (x / rect.width) * 2 - 1;
        mouse.y = -(y / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(pointsGroup.children, true);

        if (intersects.length > 0) {
          const obj = intersects[0].object;
          const d = obj.userData;
          if (d) {
            tooltip.style.left = x + 10 + "px";
            tooltip.style.top = y + 10 + "px";

            let html = "";

            if (d.region_label) {
              html += "<b>" + d.region_label + "</b><br/>";
            }

            html += "Typ: <b>" + d.event_type + "</b><br/>";

            html +=
              "Lat: " + d.lat.toFixed(1) + "° &nbsp; Lon: " + d.lon.toFixed(1) + "°<br/>" +
              "Local time: " + d.local_hour.toFixed(1) + " h<br/>" +
              "HR: " + d.HR.toFixed(1) + " bpm &nbsp; HRV: " + d.HRV.toFixed(1) + "<br/>" +
              "risk_index: " + d.risk_index.toFixed(2) + "<br/>";

            if (d.reason) {
              html += "<span style='color:#aeb3d9'>Uzasadnienie (demo):</span><br/>" +
                      "<span style='color:#d9ddff'>" + d.reason + "</span>";
            }

            tooltip.innerHTML = html;
            tooltip.style.opacity = 1;
          } else {
            tooltip.style.opacity = 0;
          }
        } else {
          tooltip.style.opacity = 0;
        }
      }

      function onMouseMove(event) {
        updateTooltip(event);
        if (!isDragging) return;
        const rect = container.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const dx = x - prevMouse.x;
        const dy = y - prevMouse.y;
        prevMouse.x = x;
        prevMouse.y = y;
        targetRot.y += dx * 0.005;
        targetRot.x += dy * 0.005;
        targetRot.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRot.x));
      }

      function onMouseDown(event) {
        isDragging = true;
        const rect = container.getBoundingClientRect();
        prevMouse.x = event.clientX - rect.left;
        prevMouse.y = event.clientY - rect.top;
      }

      function onMouseUp() {
        isDragging = false;
      }

      function animate() {
        requestAnimationFrame(animate);

        // Auto–obrót
        targetRot.y += 0.001;

        currentRot.x += (targetRot.x - currentRot.x) * 0.12;
        currentRot.y += (targetRot.y - currentRot.y) * 0.12;

        [globeMesh, wireMesh, atmosphereMesh, pointsGroup].forEach((obj) => {
          if (!obj) return;
          obj.rotation.x = currentRot.x;
          obj.rotation.y = currentRot.y;
        });

        const t = performance.now() / 1000;
        pointsGroup.children.forEach((mesh) => {
          const d = mesh.userData;
          if (!d || typeof d.baseSize !== "number") return;
          const r = d.risk_index || 0;
          const amp = 0.35 * r + 0.15;
          const s = 1 + amp * Math.sin(t * 2.2 + r * 6.0);
          const scale = Math.max(0.7, s);
          mesh.scale.setScalar(scale);
        });

        renderer.render(scene, camera);
      }

      function updateMetrics(visibleData) {
        const arr = visibleData && visibleData.length ? visibleData : globeData;

        if (!arr || arr.length === 0) {
          mAvgHR.textContent = "–";
          mAvgHRV.textContent = "–";
          mCount.textContent = "0";
          mEvents.textContent = "N:0 · H:0 · F:0 · C:0 · I:0";
          return;
        }

        let sumHR = 0;
        let sumHRV = 0;
        const counts = {
          normal: 0,
          heatwave_risk: 0,
          flood_risk: 0,
          conflict_risk: 0,
          infrastructure_stress: 0,
        };

        arr.forEach((p) => {
          sumHR += p.HR;
          sumHRV += p.HRV;
          if (counts[p.event_type] !== undefined) counts[p.event_type]++;
        });

        const n = arr.length;
        mAvgHR.textContent = (sumHR / n).toFixed(1);
        mAvgHRV.textContent = (sumHRV / n).toFixed(1);
        mCount.textContent = String(n);

        mEvents.textContent =
          "N:" + counts.normal +
          " · H:" + counts.heatwave_risk +
          " · F:" + counts.flood_risk +
          " · C:" + counts.conflict_risk +
          " · I:" + counts.infrastructure_stress;
      }

      // --- DEMO DATA: wyraźne, kolorowe klastry + region_label + reason ---
      function loadDemoDataOnly() {
        dataModeLabel.textContent = "DEMO / offline";
        snapshotTimeLabel.textContent = "(syntetyczny jednominutowy snapshot)";
        globeData = generateClusteredDemoData();
        buildPoints();
      }

      function pickRandom(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }

      function generateClusteredDemoData() {
        const out = [];
        const now = new Date().toISOString();

        const heatRegions = [
          "Sahel (Afryka)",
          "Północne Indie / Pakistan",
          "Półwysep Arabski"
        ];
        const floodRegions = [
          "Delta rzeki w strefie tropikalnej",
          "Wybrzeże monsunowe",
          "Nisko położone wyspy równikowe"
        ];
        const conflictRegions = [
          "Europa Wschodnia",
          "Bliski Wschód",
          "Strefa konfliktu (płn. Afryka)"
        ];
        const infraRegions = [
          "Megamiasto (Ameryka Płn.)",
          "Megamiasto (Europa)",
          "Megamiasto (Azja Wschodnia)"
        ];
        const normalRegions = [
          "Obszar wiejski",
          "Miasto o umiarkowanym obciążeniu",
          "Strefa przybrzeżna",
          "Wnętrze kontynentu"
        ];

        // normal – rozproszone
        for (let i = 0; i < 400; i++) {
          const lat = (Math.random() * 160) - 80;
          const lon = (Math.random() * 360) - 180;
          const localHour = (12 + lon / 15 + 24) % 24;
          const HR = clamp(65 + randn() * 6, 45, 110);
          const HRV = clamp(70 + randn() * 10, 20, 140);
          const risk = clamp(0.1 + Math.random() * 0.3, 0, 1);
          out.push({
            lat,
            lon,
            timestamp_utc: now,
            local_hour: localHour,
            HR,
            HRV,
            risk_index: risk,
            event_type: "normal",
            region_label: pickRandom(normalRegions),
            reason: "Typowa dobowa fizjologia populacji; brak wyraźnych sygnałów kryzysowych (baseline)."
          });
        }

        // heatwave_risk – 10–35N, Afryka / Bliski Wschód / Indie
        for (let i = 0; i < 120; i++) {
          const lat = 10 + Math.random() * 25;
          const lon = -20 + Math.random() * 100;
          const localHour = (12 + lon / 15 + 24) % 24;
          const HR = clamp(80 + randn() * 8, 55, 130);
          const HRV = clamp(50 + randn() * 10, 10, 110);
          const risk = clamp(0.6 + Math.random() * 0.4, 0, 1);
          out.push({
            lat,
            lon,
            timestamp_utc: now,
            local_hour: localHour,
            HR,
            HRV,
            risk_index: risk,
            event_type: "heatwave_risk",
            region_label: pickRandom(heatRegions),
            reason: "Podwyższony HR, obniżone HRV i lokalne warunki gorącego, suchego klimatu – scenariusz długotrwałej fali upałów (demo)."
          });
        }

        // flood_risk – pas równikowy
        for (let i = 0; i < 120; i++) {
          const lat = -10 + Math.random() * 20;
          const lon = -160 + Math.random() * 320;
          const localHour = (12 + lon / 15 + 24) % 24;
          const HR = clamp(72 + randn() * 7, 50, 120);
          const HRV = clamp(65 + randn() * 12, 15, 130);
          const risk = clamp(0.55 + Math.random() * 0.45, 0, 1);
          out.push({
            lat,
            lon,
            timestamp_utc: now,
            local_hour: localHour,
            HR,
            HRV,
            risk_index: risk,
            event_type: "flood_risk",
            region_label: pickRandom(floodRegions),
            reason: "Pas równikowy o wysokiej wilgotności, korelacja z epizodami intensywnych opadów i lokalnym podniesieniem HR (demo)."
          });
        }

        // conflict_risk – 30–60N, -20 do 120E
        for (let i = 0; i < 120; i++) {
          const lat = 30 + Math.random() * 30;
          const lon = -20 + Math.random() * 140;
          const localHour = (12 + lon / 15 + 24) % 24;
          const HR = clamp(78 + randn() * 9, 55, 135);
          const HRV = clamp(55 + randn() * 12, 10, 120);
          const risk = clamp(0.6 + Math.random() * 0.4, 0, 1);
          out.push({
            lat,
            lon,
            timestamp_utc: now,
            local_hour: localHour,
            HR,
            HRV,
            risk_index: risk,
            event_type: "conflict_risk",
            region_label: pickRandom(conflictRegions),
            reason: "Zwiększone obciążenie stresem populacyjnym (HR↑, HRV↓) w regionie o znanym napięciu geopolitycznym (scenariusz konfliktowy – demo)."
          });
        }

        // infrastructure_stress – 40–60N, -130 do 130
        for (let i = 0; i < 120; i++) {
          const lat = 40 + Math.random() * 20;
          const lon = -130 + Math.random() * 260;
          const localHour = (12 + lon / 15 + 24) % 24;
          const HR = clamp(75 + randn() * 7, 50, 125);
          const HRV = clamp(60 + randn() * 10, 20, 130);
          const risk = clamp(0.55 + Math.random() * 0.45, 0, 1);
          out.push({
            lat,
            lon,
            timestamp_utc: now,
            local_hour: localHour,
            HR,
            HRV,
            risk_index: risk,
            event_type: "infrastructure_stress",
            region_label: pickRandom(infraRegions),
            reason: "Wysoka aktywność w gęsto zaludnionej aglomeracji (dojazdy, praca zmianowa, przeciążenie sieci); wzorzec przeciążenia infrastruktury (demo)."
          });
        }

        return out;
      }

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }

      function randn() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2 * Math.PI * v);
      }

      function initControls() {
        checkboxes.forEach((cb) => {
          cb.addEventListener("change", () => buildPoints());
        });
        riskSlider.addEventListener("input", () => {
          const v = parseFloat(riskSlider.value) / 100.0;
          riskValueLabel.textContent = v.toFixed(2);
          buildPoints();
        });
      }

      initScene();
      initControls();
      loadDemoDataOnly();
    })();
  </script>
</body>
</html>
