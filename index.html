<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Global Heartbeat AI – Planetarny puls ludzkości</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Global Heartbeat AI – interaktywny globus 3D wizualizujący jednominutowy puls ludzkości z warstwą AI analizującą ryzyko środowiskowe i społeczne."
  />
  <style>
    :root {
      --bg-main: #050713;
      --bg-panel: rgba(7, 10, 28, 0.96);
      --border-soft: rgba(142, 162, 255, 0.35);
      --accent: #b3c7ff;
      --accent-strong: #ff8ddc;
      --accent-warm: #ffc857;
      --text-main: #f5f7ff;
      --text-soft: #aeb3d9;
      --radius-xl: 18px;
      --shadow-soft: 0 18px 40px rgba(0, 0, 0, 0.55);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at 10% 0, #262f72 0, transparent 45%),
        radial-gradient(circle at 80% 120%, #3d1649 0, transparent 55%),
        var(--bg-main);
      color: var(--text-main);
      overflow: hidden;
    }

    body {
      display: grid;
      grid-template-columns: minmax(0, 1.5fr) minmax(380px, 0.9fr);
      grid-template-rows: 100vh;
    }

    #globe-shell {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 18px;
    }

    #globe-container {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: var(--radius-xl);
      overflow: hidden;
      box-shadow: var(--shadow-soft);
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: radial-gradient(circle at top, #1a2148, #050713 65%);
    }

    #tooltip {
      position: absolute;
      pointer-events: none;
      background: rgba(5, 7, 24, 0.97);
      border-radius: 10px;
      padding: 8px 10px;
      border: 1px solid rgba(163, 190, 255, 0.8);
      font-size: 11px;
      color: var(--text-main);
      white-space: nowrap;
      transform: translate(10px, 10px);
      opacity: 0;
      transition: opacity 0.1s ease-out;
      z-index: 10;
      max-width: 260px;
    }

    /* Prawy panel */
    #side-panel {
      height: 100vh;
      padding: 18px 18px 18px 0;
      display: flex;
      flex-direction: column;
    }

    .panel-card {
      background: var(--bg-panel);
      border-radius: var(--radius-xl);
      border: 1px solid var(--border-soft);
      box-shadow: var(--shadow-soft);
      padding: 14px 16px;
      margin-bottom: 12px;
    }

    #header-card {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .brand-label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--accent);
      opacity: 0.9;
    }

    .brand-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: radial-gradient(circle, var(--accent-strong), transparent 70%);
      box-shadow: 0 0 10px var(--accent-strong);
    }

    h1 {
      font-size: 20px;
      margin: 0;
      letter-spacing: 0.02em;
    }

    .subtitle {
      font-size: 12px;
      color: var(--text-soft);
      margin: 0;
    }

    .tag-row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 6px;
    }

    .tag {
      font-size: 10px;
      padding: 3px 7px;
      border-radius: 999px;
      border: 1px solid rgba(180, 195, 255, 0.7);
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    #controls-card { font-size: 11px; }

    #controls-card h2,
    #metrics-card h2,
    #about-card h2 {
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--accent);
      margin: 0 0 6px;
    }

    #controls-card label {
      display: flex;
      align-items: center;
      gap: 4px;
      margin-bottom: 3px;
      cursor: pointer;
    }

    #controls-card input[type="checkbox"] {
      accent-color: var(--accent-strong);
    }

    #risk-value {
      font-variant-numeric: tabular-nums;
      color: var(--accent-warm);
      font-weight: 600;
    }

    #risk-slider { width: 100%; }

    .controls-row {
      margin-top: 8px;
      padding-top: 6px;
      border-top: 1px dashed rgba(120, 130, 190, 0.6);
    }

    /* Metrics */
    #metrics-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }

    .metric-tile {
      background: radial-gradient(circle at top, rgba(60, 70, 140, 0.9), rgba(7, 10, 28, 0.95));
      border-radius: 12px;
      padding: 6px 7px;
      border: 1px solid rgba(147, 164, 255, 0.8);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.7);
    }

    .metric-label {
      font-size: 10px;
      color: var(--text-soft);
      margin-bottom: 2px;
    }

    .metric-value {
      font-size: 13px;
      font-variant-numeric: tabular-nums;
    }

    .metric-unit {
      font-size: 10px;
      color: var(--text-soft);
      margin-left: 2px;
    }

    .metric-pill {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      margin-top: 3px;
      display: inline-block;
      color: var(--accent);
    }

    #m-events {
      font-variant-numeric: tabular-nums;
      color: var(--accent);
    }

    /* About / sections */
    #about-card {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    #about-scroll {
      overflow-y: auto;
      padding-right: 4px;
      max-height: 100%;
    }

    .about-block { margin-bottom: 10px; }

    .about-block h3 {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      margin: 0 0 4px;
      color: var(--accent);
    }

    .about-block p {
      font-size: 11px;
      color: var(--text-soft);
      margin: 0;
      line-height: 1.4;
    }

    .about-list {
      margin: 4px 0 0;
      padding-left: 14px;
      font-size: 11px;
      color: var(--text-soft);
    }

    .about-list li { margin-bottom: 3px; }

    code {
      font-family: "JetBrains Mono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 10px;
      background: rgba(10, 12, 32, 0.9);
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid rgba(110, 130, 210, 0.5);
    }

    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    @media (max-width: 900px) {
      body {
        grid-template-columns: 1fr;
        grid-template-rows: 55vh 45vh;
      }
      #side-panel { padding: 0 12px 12px 12px; }
      #globe-shell { padding: 10px; }
      #globe-container { border-radius: 14px; }
    }
  </style>
</head>
<body>
  <!-- LEWA: GLOBUS 3D -->
  <div id="globe-shell">
    <div id="globe-container">
      <div id="tooltip"></div>
    </div>
  </div>

  <!-- PRAWA: PANEL -->
  <aside id="side-panel">
    <section id="header-card" class="panel-card">
      <div class="brand-label">
        <span class="brand-dot"></span>
        GLOBAL HEARTBEAT AI
      </div>
      <h1>Planetarny puls ludzkości</h1>
      <p class="subtitle">
        Interaktywny globus 3D łączący dane o rytmie serca z warstwą AI szacującą lokalne ryzyko środowiskowe i społeczne.
      </p>
      <div class="tag-row">
        <span class="tag">Biometrics</span>
        <span class="tag">Earth data</span>
        <span class="tag">AI risk mapping</span>
      </div>
    </section>

    <section id="controls-card" class="panel-card">
      <h2>Filtry zdarzeń / ryzyka</h2>
      <div>
        <label><input type="checkbox" data-event="normal" checked /> normal</label>
        <label><input type="checkbox" data-event="heatwave_risk" checked /> heatwave_risk</label>
        <label><input type="checkbox" data-event="flood_risk" checked /> flood_risk</label>
        <label><input type="checkbox" data-event="conflict_risk" checked /> conflict_risk</label>
        <label><input type="checkbox" data-event="infrastructure_stress" checked /> infrastructure_stress</label>
      </div>
      <div class="controls-row">
        Min. risk_index:
        <span id="risk-value">0.00</span><br />
        <input id="risk-slider" type="range" min="0" max="100" value="0" />
        <p style="margin:4px 0 0; color:var(--text-soft); font-size:10px;">
          Przesuń w prawo, aby zobaczyć tylko najbardziej obciążone punkty.
        </p>
      </div>
      <div class="controls-row" style="display:flex;justify-content:space-between;align-items:center;">
        <span style="font-size:10px;color:var(--text-soft);">
          Źródło danych:
          <span id="data-mode-label" style="color:var(--accent-warm); font-weight:600;">API / live</span>
        </span>
        <span style="font-size:10px;color:var(--text-soft);" id="snapshot-time"></span>
      </div>
    </section>

    <section id="metrics-card" class="panel-card">
      <h2>Szybkie metryki snapshotu</h2>
      <div id="metrics-grid">
        <div class="metric-tile">
          <div class="metric-label">Średni HR</div>
          <div class="metric-value"><span id="m-avg-hr">–</span><span class="metric-unit">bpm</span></div>
          <div class="metric-pill">dzień+noc</div>
        </div>
        <div class="metric-tile">
          <div class="metric-label">Średni HRV</div>
          <div class="metric-value"><span id="m-avg-hrv">–</span><span class="metric-unit">unit</span></div>
          <div class="metric-pill">zmienność</div>
        </div>
        <div class="metric-tile">
          <div class="metric-label">Widoczne punkty</div>
          <div class="metric-value"><span id="m-count">–</span></div>
          <div class="metric-pill">po filtrach</div>
        </div>
      </div>
      <div style="margin-top:6px;font-size:10px;color:var(--text-soft);">
        Aktywne zdarzenia: <span id="m-events">–</span>
      </div>
    </section>

    <section id="about-card" class="panel-card">
      <h2>O projekcie / naukowe tło</h2>
      <div id="about-scroll">
        <div class="about-block">
          <h3>Co oglądasz?</h3>
          <p>
            Każdy punkt na globusie reprezentuje lokalny fragment pulsu ludzkości:
            zanonimizowaną grupę osób z określonym tętnem (<b>HR</b>), zmiennością rytmu serca (<b>HRV</b>)
            i lokalnym czasem. Kolor punktu to etykieta AI (<code>event_type</code>), a rozmiar – indeks ryzyka
            (<code>risk_index</code>).
          </p>
        </div>

        <div class="about-block">
          <h3>Warstwa AI (simplified)</h3>
          <p>
            Warstwa AI łączy informacje fizjologiczne (HR, HRV, faza doby) z danymi środowiskowymi i kryzysowymi.
            Dla każdego punktu obliczany jest:
          </p>
          <ul class="about-list">
            <li><code>risk_index</code> – liczba 0–1 opisująca obciążenie / ryzyko,</li>
            <li><code>event_type</code> – klasa zdarzenia: <em>normal, heatwave_risk, flood_risk, conflict_risk, infrastructure_stress</em>.</li>
          </ul>
        </div>

        <div class="about-block">
          <h3>Architektura systemu</h3>
          <p>System Global Heartbeat AI obejmuje:</p>
          <ul class="about-list">
            <li><b>Warstwę danych</b> – strumienie HR/HRV + dane środowiskowe,</li>
            <li><b>Silnik analityczny</b> – agregacja do jednominutowych snapshotów i wyliczanie metryk,</li>
            <li><b>Moduł AI</b> – szacowanie ryzyka i tagowanie zdarzeń,</li>
            <li><b>Globus 3D</b> – wizualizację w czasie zbliżonym do rzeczywistego.</li>
          </ul>
          <p style="margin-top:4px;">
            Ten widok prezentuje pojedynczy snapshot; w wersji rozszerzonej globus może być animowany w czasie
            i połączony z panelami analitycznymi (wykresy, porównania regionów, historia zdarzeń).
          </p>
        </div>

        <div class="about-block">
          <h3>Uwaga o danych</h3>
          <p>
            W trybie demonstracyjnym dane są syntetyczne, ale struktura jest zgodna z docelowym systemem.
            Po podłączeniu backendu / API, globus może pracować na prawdziwych strumieniach HR/HRV z urządzeń
            noszonych oraz na rzeczywistych danych pogodowych i kryzysowych.
          </p>
        </div>
      </div>
    </section>
  </aside>

  <!-- SCRIPT: moduł z importem THREE -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.161.0/build/three.module.js";

    (function() {
      const API_BASE = "http://localhost:8000";
      const SNAPSHOT_ENDPOINT = API_BASE + "/globe/snapshot?n_points=2000";

      const container = document.getElementById("globe-container");
      const tooltip = document.getElementById("tooltip");
      const riskSlider = document.getElementById("risk-slider");
      const riskValueLabel = document.getElementById("risk-value");
      const dataModeLabel = document.getElementById("data-mode-label");
      const snapshotTimeLabel = document.getElementById("snapshot-time");
      const checkboxes = Array.from(
        document.querySelectorAll('#controls-card input[type="checkbox"]')
      );

      const mAvgHR = document.getElementById("m-avg-hr");
      const mAvgHRV = document.getElementById("m-avg-hrv");
      const mCount = document.getElementById("m-count");
      const mEvents = document.getElementById("m-events");

      let scene, camera, renderer;
      let globeMesh, wireMesh, atmosphereMesh;
      let pointsGroup;
      let raycaster, mouse;
      let isDragging = false;
      let prevMouse = { x: 0, y: 0 };
      let targetRot = { x: 0, y: 0 };
      let currentRot = { x: 0, y: 0 };
      let globeData = [];

      const radius = 1.2;

      const colorMap = {
        normal: new THREE.Color(0x7fd2ff),
        heatwave_risk: new THREE.Color(0xffa34f),
        flood_risk: new THREE.Color(0x5b9dff),
        conflict_risk: new THREE.Color(0xff5fb3),
        infrastructure_stress: new THREE.Color(0xffd469),
      };

      function initScene() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050713);

        const width = container.clientWidth || window.innerWidth;
        const height = container.clientHeight || window.innerHeight;

        camera = new THREE.PerspectiveCamera(52, width / height, 0.1, 100);
        camera.position.set(0, 0, 4.2);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(width, height);
        container.appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.75);
        scene.add(ambient);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.95);
        dirLight.position.set(3, 2, 3);
        scene.add(dirLight);

        const globeGeo = new THREE.SphereGeometry(radius, 64, 64);
        const globeMat = new THREE.MeshPhongMaterial({
          color: 0x3246a0,
          emissive: 0x050713,
          shininess: 32,
          transparent: true,
          opacity: 0.96,
        });
        globeMesh = new THREE.Mesh(globeGeo, globeMat);
        scene.add(globeMesh);

        const wireGeo = new THREE.SphereGeometry(radius * 1.003, 32, 32);
        const wireMat = new THREE.MeshBasicMaterial({
          color: 0x5569c8,
          wireframe: true,
          transparent: true,
          opacity: 0.34,
        });
        wireMesh = new THREE.Mesh(wireGeo, wireMat);
        scene.add(wireMesh);

        const atmoGeo = new THREE.SphereGeometry(radius * 1.06, 40, 40);
        const atmoMat = new THREE.MeshBasicMaterial({
          color: 0x88c2ff,
          transparent: true,
          opacity: 0.2,
        });
        atmosphereMesh = new THREE.Mesh(atmoGeo, atmoMat);
        scene.add(atmosphereMesh);

        const starsGeometry = new THREE.BufferGeometry();
        const starCount = 900;
        const positions = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
          const r = 9 + Math.random() * 8;
          const theta = Math.random() * 2 * Math.PI;
          const phi = Math.acos(2 * Math.random() - 1);
          positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
          positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
          positions[i * 3 + 2] = r * Math.cos(phi);
        }
        starsGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
        const starsMaterial = new THREE.PointsMaterial({
          size: 0.04,
          color: 0xaec4ff,
          transparent: true,
          opacity: 0.45,
        });
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        pointsGroup = new THREE.Group();
        scene.add(pointsGroup);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

        window.addEventListener("resize", onResize);
        container.addEventListener("mousemove", onMouseMove);
        container.addEventListener("mouseleave", () => (tooltip.style.opacity = 0));
        container.addEventListener("mousedown", onMouseDown);
        container.addEventListener("mouseup", onMouseUp);
        container.addEventListener("mouseout", onMouseUp);

        animate();
      }

      function onResize() {
        const width = container.clientWidth || window.innerWidth;
        const height = container.clientHeight || window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }

      function latLonToVector3(lat, lon, r = radius) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180);
        const x = -r * Math.sin(phi) * Math.cos(theta);
        const z = r * Math.sin(phi) * Math.sin(theta);
        const y = r * Math.cos(phi);
        return new THREE.Vector3(x, y, z);
      }

      function clearPoints() {
        while (pointsGroup.children.length > 0) {
          const child = pointsGroup.children.pop();
          child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) child.material.forEach((m) => m.dispose());
            else child.material.dispose();
          }
        }
      }

      function buildPoints() {
        clearPoints();
        if (!globeData || globeData.length === 0) {
          updateMetrics([]);
          return;
        }

        const minRisk = parseFloat(riskSlider.value) / 100.0;
        const enabledEvents = new Set(
          checkboxes.filter((cb) => cb.checked).map((cb) => cb.dataset.event)
        );

        const visible = [];

        globeData.forEach((p) => {
          if (!enabledEvents.has(p.event_type)) return;
          if (p.risk_index < minRisk) return;

          visible.push(p);

          const pos = latLonToVector3(p.lat, p.lon);
          const size = 0.012 + 0.04 * p.risk_index;

          const geom = new THREE.SphereGeometry(size, 14, 14);
          const baseColor = colorMap[p.event_type] || colorMap.normal;
          const mat = new THREE.MeshPhongMaterial({
            color: baseColor,
            emissive: baseColor.clone().multiplyScalar(0.9),
            shininess: 70,
          });

          const mesh = new THREE.Mesh(geom, mat);
          mesh.position.copy(pos);
          mesh.userData = {
            ...p,
            baseSize: size,
          };
          pointsGroup.add(mesh);
        });

        updateMetrics(visible);
      }

      function updateTooltip(event) {
        const rect = container.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;

        mouse.x = (x / rect.width) * 2 - 1;
        mouse.y = -(y / rect.height) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(pointsGroup.children, true);

        if (intersects.length > 0) {
          const obj = intersects[0].object;
          const d = obj.userData;
          if (d) {
            tooltip.style.left = x + 10 + "px";
            tooltip.style.top = y + 10 + "px";
            tooltip.innerHTML =
              "Lat: " + d.lat.toFixed(1) + "°<br/>" +
              "Lon: " + d.lon.toFixed(1) + "°<br/>" +
              "Local time: " + d.local_hour.toFixed(1) + " h<br/>" +
              "HR: " + d.HR.toFixed(1) + " bpm<br/>" +
              "HRV: " + d.HRV.toFixed(1) + "<br/>" +
              "risk_index: " + d.risk_index.toFixed(2) + "<br/>" +
              "AI tag: <b>" + d.event_type + "</b>";
            tooltip.style.opacity = 1;
          } else {
            tooltip.style.opacity = 0;
          }
        } else {
          tooltip.style.opacity = 0;
        }
      }

      function onMouseMove(event) {
        updateTooltip(event);
        if (!isDragging) return;
        const rect = container.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const dx = x - prevMouse.x;
        const dy = y - prevMouse.y;
        prevMouse.x = x;
        prevMouse.y = y;
        targetRot.y += dx * 0.005;
        targetRot.x += dy * 0.005;
        targetRot.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetRot.x));
      }

      function onMouseDown(event) {
        isDragging = true;
        const rect = container.getBoundingClientRect();
        prevMouse.x = event.clientX - rect.left;
        prevMouse.y = event.clientY - rect.top;
      }

      function onMouseUp() {
        isDragging = false;
      }

      function animate() {
        requestAnimationFrame(animate);

        // Auto–obrót
        targetRot.y += 0.0009;

        currentRot.x += (targetRot.x - currentRot.x) * 0.12;
        currentRot.y += (targetRot.y - currentRot.y) * 0.12;

        [globeMesh, wireMesh, atmosphereMesh, pointsGroup].forEach((obj) => {
          if (!obj) return;
          obj.rotation.x = currentRot.x;
          obj.rotation.y = currentRot.y;
        });

        // Pulsowanie punktów (oddech zależny od risk_index)
        const t = performance.now() / 1000;
        pointsGroup.children.forEach((mesh) => {
          const d = mesh.userData;
          if (!d || typeof d.baseSize !== "number") return;
          const r = d.risk_index || 0;
          const amp = 0.4 * r + 0.1;
          const s = 1 + amp * Math.sin(t * 1.8 + r * 7.0);
          const scale = Math.max(0.5, s);
          mesh.scale.setScalar(scale);
        });

        renderer.render(scene, camera);
      }

      function updateMetrics(visibleData) {
        const arr = visibleData && visibleData.length ? visibleData : globeData;

        if (!arr || arr.length === 0) {
          mAvgHR.textContent = "–";
          mAvgHRV.textContent = "–";
          mCount.textContent = "0";
          mEvents.textContent = "N:0 · H:0 · F:0 · C:0 · I:0";
          return;
        }

        let sumHR = 0;
        let sumHRV = 0;
        const counts = {
          normal: 0,
          heatwave_risk: 0,
          flood_risk: 0,
          conflict_risk: 0,
          infrastructure_stress: 0,
        };

        arr.forEach((p) => {
          sumHR += p.HR;
          sumHRV += p.HRV;
          if (counts[p.event_type] !== undefined) counts[p.event_type]++;
        });

        const n = arr.length;
        mAvgHR.textContent = (sumHR / n).toFixed(1);
        mAvgHRV.textContent = (sumHRV / n).toFixed(1);
        mCount.textContent = String(n);

        mEvents.textContent =
          "N:" + counts.normal +
          " · H:" + counts.heatwave_risk +
          " · F:" + counts.flood_risk +
          " · C:" + counts.conflict_risk +
          " · I:" + counts.infrastructure_stress;
      }

      async function loadDataFromApi() {
        try {
          const res = await fetch(SNAPSHOT_ENDPOINT);
          if (!res.ok) throw new Error("HTTP " + res.status);
          const json = await res.json();
          globeData = json.points || [];
          dataModeLabel.textContent = "API / live";
          if (json.timestamp_utc) {
            snapshotTimeLabel.textContent = new Date(json.timestamp_utc).toISOString();
          }
          buildPoints();
        } catch (err) {
          console.warn("API niedostępne, tryb DEMO:", err);
          dataModeLabel.textContent = "DEMO / offline";
          snapshotTimeLabel.textContent = "(syntetyczny snapshot)";
          globeData = generateDemoData(2000);
          buildPoints();
        }
      }

      function generateDemoData(n) {
        const out = [];
        for (let i = 0; i < n; i++) {
          const lat = (Math.random() * 140) - 70;
          const lon = (Math.random() * 360) - 180;
          const localHour = (12 + lon / 15 + 24) % 24;
          const baselineHR = 70 - 10 * Math.cos((localHour - 11) * 2 * Math.PI / 24);
          const HR = clamp(baselineHR + randn() * 6, 45, 120);
          const baselineHRV = 60 + 20 * Math.cos((localHour - 3) * 2 * Math.PI / 24);
          const HRV = clamp(baselineHRV + randn() * 10, 10, 140);
          const normHR = (HR - 45) / (120 - 45);
          const normHRV = (HRV - 10) / (140 - 10);
          let risk = normHR - normHRV + randn() * 0.08;
          risk = (risk - (-1)) / (1 - (-1));
          risk = clamp(risk, 0, 1);

          let eventType = "normal";
          if (risk > 0.78 && lat > 20) eventType = "heatwave_risk";
          if (risk > 0.7 && lat < 25 && lat > -5 && lon < -20) eventType = "flood_risk";
          if (risk > 0.7 && lat > 30 && lon > -10 && lon < 50) eventType = "conflict_risk";
          if (risk > 0.7 && lat > 35 && lon < -30) eventType = "infrastructure_stress";

          out.push({
            lat,
            lon,
            timestamp_utc: new Date().toISOString(),
            local_hour: localHour,
            theta: localHour * 2 * Math.PI / 24,
            HR,
            HRV,
            risk_index: risk,
            event_type: eventType,
          });
        }
        return out;
      }

      function clamp(v, min, max) {
        return Math.max(min, Math.min(max, v));
      }

      function randn() {
        let u = 0, v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2 * Math.PI * v);
      }

      function initControls() {
        checkboxes.forEach((cb) => {
          cb.addEventListener("change", () => buildPoints());
        });
        riskSlider.addEventListener("input", () => {
          const v = parseFloat(riskSlider.value) / 100.0;
          riskValueLabel.textContent = v.toFixed(2);
          buildPoints();
        });
      }

      initScene();
      initControls();
      loadDataFromApi();
    })();
  </script>
</body>
</html>
